# 有趣题目

---

## 偶数计数器

**第一版**：

```python
count = 0
for number in range(1, 10):
    if number % 2 == 0:
        count += 1
        print(number)    #for循环遍历之后再走到下一步
print(f"We have {count} even numbers")
```

- 优点：每出现一个偶数，count 就+1
- 缺点：只是自己自娱自乐



**第二版**：

```python
# 让用户输入范围（整数）
start = int(input("请输入起始整数："))
end   = int(input("请输入结束整数："))

count = 0
for number in range(start, end + 1):   # 终点要 +1 才能包含 end，在这直接用表达式表达参数
    if number % 2 == 0:
        count += 1
        print(number)

print(f"在 {start} 到 {end} 之间有 {count} 个偶数")
```

- 优点：有了互动性
- 缺点：没有扩大到别的数集



**第三版**：

```python
import math
print("这是一个偶数检索器")
start = float(input("请输入起始数："))
end = float(input("请输入结束数："))
print("请注意起始和结束数字也被包含其中！")
start1 = math.ceil(start)
end1 = math.floor(end)
COUNT = 0
for number in range(start1, end1 + 1):   # 终点要+1才能包含 end，在这直接用表达式表达参数
    if number % 2 == 0:
        COUNT += 1
        print(number)

print(f"在 {start} 到 {end} 之间有 {COUNT} 个偶数")
```

- 用 `ceil` 和 `floor` 函数让小数取整
- 注意小数点字符串只能用 `float` 转变为数字



**第四版**：

```python
import math
import sys

def pretty(num):
    if num.is_integer():
        return str(int(num))
    else:
        return str(num)

print("这是一个偶数检索器(起始和结束数字也被包含其中！)")
start = float(input("请输入起始数："))
end = float(input("请输入结束数："))
count = 0
if start > end:
    print("起始数字不能大于结束数字！")
    sys.exit(1)
elif start == end:
    if start % 2 == 0:
        count += 1
        print(start)
    msg = f"在 {pretty(start)} 到 {pretty(end)} 之间有 {count} 个偶数" if count else "区间内没有偶数"
    print(msg)
else:
    start1 = math.ceil(start)
    end1 = math.floor(end)
    for number in range(start1, end1 + 1):   # 终点要+1才能包含 end，在这直接用表达式表达参数
        if number % 2 == 0:
            count += 1
            print(number)
    msg = f"在 {pretty(start)} 到 {pretty(end)} 之间有 {count} 个偶数" if count else "区间内没有偶数"
    print(msg)

```

- 定义函数 pretty 后用    if num.is_integer(): 判断是否带.0 这类无效信息，优化美观性
- `msg = …… if count else ` 利用三元表达式一口气简化代码
- python 中默认非零为 True，零视为 False

缺点——

- start > end 后直接 exit，而不是重头重新输入
- 模块前面有说明，但函数没有说明



**第五版**：

```python
"""
这是一个介绍
"""
import math


def pretty(num):
    """
    把浮点数格式化为去掉多余 .0 的字符串。
    """
    return str(int(num)) if num.is_integer() else str(num)


print("这是一个偶数检索器(起始和结束数字也被包含其中！)")
while True:
    try:
        start = float(input("请输入起始数："))
        end = float(input("请输入结束数："))
    except ValueError:
        print("请输入有效的数字！")
        continue
    if start > end:
        print("起始数字不能大于结束数字！请重新输入。")
        continue
    break
count = 0

if start == end:
    if start % 2 == 0:
        count += 1
        print(start)
    msg = f"在 {pretty(start)} 到 {pretty(end)} 之间有 {count} 个偶数" if count else "区间内没有偶数"
    print(msg)
else:
    start1 = math.ceil(start)
    end1 = math.floor(end)

    for number in range(start1, end1 + 1):   # 终点要+1才能包含 end，在这直接用表达式表达参数
        if number % 2 == 0:
            count += 1
            print(number)
    msg = f"在 {pretty(start)} 到 {pretty(end)} 之间有 {count} 个偶数" if count else "区间内没有偶数"
    print(msg)

```



1. 利用 `while true - break` 堵住了用户调皮乱输入的情况！
   - while true 先设无限重复逻辑门，除非达到条件 break 否则一直无限死循环
   - try 先设立预先代码
   - except 处理异常的错误
   - if 堵住逻辑上的漏洞
   - break 为处理了错误结果后可以正常往下走了，开的退出传送门
   - continue 为中间失败了跳过循环里的后续剩余代码，并直接开始下一次循环
2. 添加了函数的说明，现在函数和模块都有说明了



**第六版**：

```python
"""
这是一个介绍
"""
import math


def pretty(num):
    """把浮点数格式化为去掉多余 .0 的字符串。"""
    return str(int(num)) if num.is_integer() else str(num)


def get_valid_range():
    """获取并验证用户输入的数字。"""
    while True:
        try:
            start = float(input("请输入起始数："))
            end = float(input("请输入结束数："))
        except ValueError:
            print("请输入有效的数字！")
            continue
        if start > end:
            print("起始数字不能大于结束数字！请重新输入。")
            continue  # 跳过循环剩余内容，重新开始循环
        return start, end  # 返回元组给函数


def find_and_print_evens(start, end):
    """查找并打印偶数，返回偶数个数。"""
    count = 0
    if start == end:
        if start % 2 == 0:
            count += 1
            print(int(start))
    else:
        start_int = math.ceil(start)
        end_int = math.floor(end)
        if start_int <= end_int:
            first_even = start_int if start_int % 2 == 0 else start_int + 1
            for number in range(first_even, end_int + 1, 2):   # 终点要+1才能包含 end，在这直接用表达式表达参数
                count += 1
                print(number)
    return count


def main():
    """主函数入口"""
    print("这是一个偶数检索器(起始和结束数字也被包含其中！)")
    start, end = get_valid_range()
    count = find_and_print_evens(start, end)
    msg = f"在 {pretty(start)} 到 {pretty(end)} 之间有 {count} 个偶数" if count else "区间内没有偶数"
    print(msg)


if __name__ == "__manin__":
    main()
```

经过 qwen 的改进后，这次最关键的、前面都没有过的优化就是 ***结构优化***！

- 结构优化：原代码所有逻辑都在主程序里，代码较长。优化后按功能和步骤将代码分为三块——获取数据，处理数据，输出结果。同时把重复的 msg 部分封装为一个函数，将三个功能拆分为三个函数职责单一，提高代码可读性、可维护性和可重复利用性，逻辑更清晰，main 协调几个函数调用
- 可读性增强：分为两方面——第一是整体结构优化逻辑优化，第二是变量命名更加明确更具描述性，第三是把重复的部分封装到一个函数中，第四是添加了更多注释解释逻辑
- 性能提升：原来需要遍历所有整数还得除 2 再次筛选，这次只用算一次，剩下就用 2 的步长遍历所有满足条件的偶数

注：

1. `if __name__ == "__manin__":`区分了两种情况——自己跑这个程序正常使用功能和引用这个模块调用函数，这样用这道门判断可以区分这两种情况。
2. 注意实参形参的对应关系，注意好相对位置才能正确对应引用数据。
3. `return`既可以返回函数输出值也可以结束循环，而`continue`则用来跳过循环剩余的部分直接重开循环

---

## Fizz_Buzz 函数

**第一版**：

```python
def fizz_buzz(input):
    if (input % 3 == 0) and (input % 5 == 0):
        return "FizzBuzz"
    if input % 3 == 0:
        return "Fizz"
    if input % 5 == 0:
        return "Buzz"
    return input


print(fizz_buzz(5))
```

` return input`为其他if条件均为假时最后返回的，省略了else

同为3和5的倍数为最窄的条件，应该放到最上面！

简单的实现了基本功能，但仍有以下缺陷：

1. 没有和用户的互动性，过于简单
2. input和内置函数重名了，不好



**第二版**：

原来我想在函数外部创立变量number，但会与函数内部的重名。但如果在函数内部使用input，则外部会显示没有定义这个全局变量。于是在函数外部重新定义新的全局变量`user_number`
